# DSA in Java

This repository contains a comprehensive collection of Data Structures and Algorithms (DSA) problems and their solutions, implemented in Java.

## Table of Contents

1. [Arrays](#1-arrays)
2. [Strings](#2-strings)
3. [Linked Lists](#3-linked-lists)
4. [Searching Algorithms](#4-searching-algorithms)
5. [Sorting Algorithms](#5-sorting-algorithms)
6. [Divide and Conquer Algorithms](#6-divide-and-conquer-algorithms)
7. [Stacks](#7-stacks)
8. [Queues](#8-queues)
9. [Tree Data Structure](#9-tree-data-structure)
10. [Graph Data Structure](#10-graph-data-structure)
11. [Greedy Methodology](#11-greedy-methodology)
12. [Recursion](#12-recursion)
13. [Backtracking Algorithms](#13-backtracking-algorithms)
14. [Dynamic Programming](#14-dynamic-programming)

---

### 1. Arrays
An array is a linear data structure that stores elements of the same type in contiguous memory locations. Arrays are useful for storing multiple values in a single variable and allow for constant-time access to elements.

### 2. Strings
A string is a sequence of characters, often used to represent text. Strings are typically implemented as arrays of characters and have a variety of operations like concatenation, slicing, and searching.

### 3. Linked Lists
A linked list is a linear data structure in which elements are stored in nodes. Each node points to the next node in the sequence, allowing for dynamic memory allocation and efficient insertion and deletion.

### 4. Searching Algorithms
Searching algorithms are techniques for finding a particular element or set of elements within a dataset. Common algorithms include linear search, binary search, and search algorithms for specific data structures like trees and graphs.

### 5. Sorting Algorithms
Sorting algorithms are methods of arranging elements in a specific order, typically either ascending or descending. Popular sorting algorithms include quicksort, mergesort, bubblesort, and heapsort.

### 6. Divide and Conquer Algorithms
Divide and conquer is a design paradigm where a problem is broken into smaller subproblems, each solved individually, and then combined to form the final solution. This technique is used in algorithms like mergesort and quicksort.

### 7. Stacks
A stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Elements are added and removed from the top of the stack, making it ideal for scenarios such as backtracking or recursive function management.

### 8. Queues
A queue is a linear data structure that follows the First In, First Out (FIFO) principle. Elements are added at the rear and removed from the front, commonly used in scheduling processes and handling asynchronous data.

### 9. Tree Data Structure
A tree is a non-linear data structure consisting of nodes connected by edges. It is used to represent hierarchical data and supports operations like traversal, insertion, and deletion. Common trees include binary trees, binary search trees, and AVL trees.

### 10. Graph Data Structure
A graph is a non-linear data structure consisting of vertices (nodes) and edges (connections between nodes). Graphs can be directed or undirected and are used to model relationships and networks such as social connections or routes between cities.

### 11. Greedy Methodology
The greedy algorithmic paradigm makes the locally optimal choice at each step with the hope of finding a global optimum. It is used in problems like the knapsack problem, job scheduling, and Huffman coding.

### 12. Recursion
Recursion is a technique in which a function calls itself to solve smaller instances of the same problem. It is used in algorithms like tree traversal, divide and conquer methods, and dynamic programming.

### 13. Backtracking Algorithms
Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally and abandoning solutions (backtracking) that fail to satisfy the constraints of the problem.

### 14. Dynamic Programming
Dynamic programming is an optimization technique that solves problems by breaking them into subproblems and storing the results of subproblems to avoid redundant calculations. It is used in algorithms like Fibonacci sequence computation and shortest path finding.
